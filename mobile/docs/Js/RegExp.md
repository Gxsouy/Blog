# `Js_Base` - `RegExp`

> 正则表达式（英语：`Regular Expression`，在代码中常简写为`regex / regexp / RE`）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。
>
> 搜索模式可用于文本搜索和文本替换。

## 修饰符 - 特殊字符

### **模式 - 修饰符**

---

| g   | 全局匹配 - **找所有**。                                                                             |
| :-- | --------------------------------------------------------------------------------------------------- |
| i   | 忽略大小写                                                                                          |
| m   | 多行 - 匹配的每一行的开始和结束是由 `\n`和`\r`分割的                                                |
| u   | `Unicode` - 可以用来查找中文的 模式 - 当然可以使用 排除法来查找中文 **`/\p{sc=Han}/gu` 查找中文。** |
| y   | 粘性匹配 - y 模式只匹配 连续的内容。 可以改变 `lastIndex`属性 来改变匹配的起始位置。                |

---

### **特殊字符**

| `.`      | 除换行外的任意单个字符 - `\n` `\r` `\u2028` `\u2029` 这几个换行符除外 |
| -------- | --------------------------------------------------------------------- |
| `\d`     | **数字** - 等价于 `[0-9]`                                             |
| `\D`     | **除了数字之外的任意字符** - 等价于 `[^0-9]`                          |
| `\w`     | 匹配 **字母 数字 下划线** - 等价于 `[A-Za-z0-9_]`                     |
| `\W`     | 匹配 **除了 `\W` 匹配之外的字符** - 等价于 `[^A-Za-z0-9_]`            |
| `\s`     | 匹配 **空白符** 包括 空格 制表符 换页符 换行符 和 其他 Unicode 空格   |
| `\S`     | 匹配 **除了 `\s` 匹配之外的字符**                                     |
| `\t`     | 匹配一个 **水平制表符 tab**                                           |
| `\r`     | 匹配一个**回车符**                                                    |
| `\n`     | 匹配一个**换行符**                                                    |
| `\v`     | 匹配一个 **垂直制表符**                                               |
| `\f`     | 匹配一个**换页符**                                                    |
| `[\b]`   | 匹配一个 **推格符**                                                   |
| `\0`     | 匹配一个 **NUL 字符** 不要再次后面跟小数点                            |
| `\cX`    | `X` 是 A - Z 的一个字母。匹配字符串中的一个控制字符。                 |
| `\x*hh*` | 匹配编码为 `*hh*` （两个十六进制数字）的字符。                        |
| `\uhhhh` | 匹配 Unicode 值为 `*hhhh*` （四个十六进制数字）的字符。               |

---

### **字符合集**

| `[xyz]`  | 一个字符集合，也叫字符组。匹配集合中的任意一个字符。也可以使用连字符`-`来指定范围<br />eg: [abcd] 等价于[a-d]。 |
| -------- | --------------------------------------------------------------------------------------------------------------- |
| `[^xyz]` | 反义字符组。 表示匹配 不在括号内的字符。（就是除外）。也可以使用连字符`-`                                       |

---

### **边界**

| `^`  | 匹配开始。                                                                      |
| ---- | ------------------------------------------------------------------------------- |
| `$`  | 匹配结尾                                                                        |
| `\b` | 匹配一个零宽单词边界。如一个字母和一个空格之间。                                |
| `\B` | 匹配一个 非零宽 单词编辑。 如两个字母之间或者两个空格之间。 ...不太懂这个定义。 |

---

### **数量词**

| `x*`         | 匹配 0 个或者多个                                                            |
| ------------ | ---------------------------------------------------------------------------- |
| `x+`         | 匹配一个或者多个 等价于 `{1,}`                                               |
| `x?`         | 匹配 0 个或者 1 一个                                                         |
| `x*?`&&`x+?` | 表示匹配的最小可能。 `/".*?"/`匹配`foo bar' = 'foo` 没有`?` 则等于 `foo bar` |
| `x ｜ y`     | 匹配 `x`或者`y`                                                              |
| `x{n}`       | `n`是一个正整数。 x 连续出现 n 次的匹配                                      |
| `x{n,}`      | `n` 是一个正整数。 x 至少出现 n 次的匹配                                     |
| `x{n,m}`     | `n`和`m`是正整数。 x 至少出现 n 次 最多出现 m 次。 n 到 m 次                 |

## 基础

### 声明创建 正则表达式

- **字面量创建**

  ```js
  let a = /x/i;
  // 字面量形式 不可以检测变量  字面量写在字符串里面然后 eval 是可以实现的
  // 因为 eval 会执行 字符串里面的内容 eg: eval('1+2') // 3 eval('1'+'2'); // 12(number类型)
  let b1 = "c";
  eval(`${/${b1}/}`).test("acbs"); // true - 只是因为 eval 会执行字符串。 不过不推荐使用 eval
  ```

- **对象创建**

  ```js
  let a = new RegExp("u", "g"); // par1 - 要匹配的字符串  par2 - 模式
  b2.test("aiu"); // true
  ```

### 一些 符号 的解析

- **`|` 选择符和 或 的意思差不多**

  ```js
  let a = 'guolin';
  /u|@/.test(a) // true
  // 如果不加 原子组的话() | 左右两边是各自的一个整体。 eg: 如下
  let tel = '010-8888888';
  /010|020\-\d{7,8}/.test(tel) // true  但是 tel = '010' 也会返回真
  /^(010|020)\-\d{7,8}$/.test(tel) // true
  ```

- **`()` - 原子表 和`[]` - 原子组**

  - `()` 原子组表示一个整体

  - `[]` 原子表 里面都是单独的 然后就有或者的意思。- 在原子表里面的括号就是普通的 字符串括号。

    **⚠️ 注： `/[(12|34)]/.test();` 在这里面 表示 ( 或 1 或 2 或 | 或 3 或 4 或 )**

- **在字面量 和 对象模式 中的差异**

  - 在 `new RegExp()` 中 `\d`就当作字符串来处理， `\d` 就是字符串 `d`。
  - **解决办法：** `\\d` 来解决匹配 `\d` 的问题。

  ```js
  let price = 21.34;
  console.log(/\d+\.\d+/.test(price)); // true
  // FIXME: 但是使用对象创建就不一样了
  let reg = new RegExp("d+.d+");
  console.log(reg.test(price)); // false
  // ⚠️：这是因为 在对象里 \d 当作字符串来处理 \d 就是 d ; \. 就是 .
  console.log("d" === "d"); // true 字符串里面 \d 就是当作d来处理
  console.log("d+.d+"); // d+.d+
  // 解决办法
  reg = new RegExp("\\d+\\.\\d+");
  console.log("\\d+\\.\\d+"); // \d+\.\d+
  console.log(reg.test(price)); // true
  // TODO: 没有定义边界的限定 那就是 相当于 g 模式来处理
  ```

- **字符的边界约束**

  - `^` 表示匹配开头。
  - `$` 表示匹配结尾。

- **`match` 方法**

  - 如果找不到就返回 `null` 。

  ```js
  this.value.match(/^[a-z]${3,5}/);
  // 这个就表示 整个都是 3到5位的字符串。 如果输入了六个 就返回 null 表示不匹配
  ```

- **数值 与 空白 元字符**

  - 匹配 数字

    ```js
    let gl = "guolin 2012";
    console.log(gl.match(/\d/)); // 2
    console.log(gl.match(/\d\d\d\d/)); // 2012
    console.log(gl.match(/\d/g)); // [2, 0, 1, 2] // 加上 g 模式就是收集所有的
    console.log(gl.match(/\d+/g)); // [2012] // 加上 g 模式就是收集所有的  + 匹配至少一个

    console.log(gl.match(/\D+/)); // guolin

    let a = "郭霖: 010-99999999, 张三：020-8888888";
    console.log(a.match(/\d{3}-\d{7-8}/g)); // 表示 前三个数字 加- 加 7到8位数字  然后g模式 表示全局搜索所有的
    ```

  - 匹配 空白元字符

    - `\s` 空白 (换行 制表符 空格 分页符等的) 都算是空白。

    - `\S` 就表示除了 `\s` 匹配到的这些。

      ```js
      /\S/.test("\nhd"); // true 是因为会找到 h 找到了一个符合条件的
      ```

- **原子表 就是里面这些都可以被匹配。 或者 的意思**

  ```js
  console.log(a.match(/[-\d:,]/g)); // [":", "0", "1", "0", "-", "9", "9", "9", "9", "9", "9", "9", "9", ",", "0", "2", "0", "-", "8", "8", "8", "8", "8", "8", "8"]  就是这些符号 就都给返回 过来了
  console.log(a.match(/[-\d:,]+/g)); // [":", "010-99999999,", "020-8888888"]
  console.log(a.match(/[^-\d:,]/g)); // ["郭", "霖", " ", " ", "张", "三", "："]  元子表里面加个 ^ 表示 除了这些我都要
  console.log(a.match(/[^-\d:,]+/g)); // ["郭霖", " ", " 张三："] 加个加号 就是返回一对的~
  ```

- **`\w` 和 `\W` 元字符**

  - `\w` 元字符 用于查找单词字符。 `a-z A-Z 0-9` 以及`_`下划线
  - `\W` 除了 `\w` 匹配的那些。 比如特殊字符@#$%...

- **`.` 点 元字符的应用**

  - `.` 就是包括除了 换行符 之外的任何字符。
  - ⚠️ 注意： `.` 如果在 原子组`[]`里面 只是一个单纯的点。

- **⚠️ 注意：在 正则表达式里面 手敲出的空格 也是作为匹配来作用的。会匹配 空格...**

- **模式 修正符号**

  - **`g` 全局匹配 表示匹配所有的，如果不加模式 那就是值匹配一次就终止了。**

  - **`i` 忽略大小写**

  - **`m` 多行匹配。**

  - **`u` 模式 匹配字符属性 - 可以用来 找 汉字啥的 (`unicode`编码)。**

    ```js
    // a [L] 就表示它是个字母
    let hd = "guolin2012.哈哈哈,";
    // ⚠️ 字母
    console.log(hd.match(/\p{L}/gu)); // (6) ["g", "u", "o", "l", "i", "n"] // 只匹配字母
    // ⚠️ 标点符号
    console.log(hd.match(/\p{P}/gu)); // (6) [".", ","] // 只匹配 标点符号

    // ⚠️ 汉字
    console.log(hd.match(/\p{sc=Han}/gu)); // ["哈", "哈", "哈"]  // 只匹配汉字

    // 使用 u 模式 就可以正确使用 宽字节去匹配了~
    ```

  - **`y` 模式 - `y`模式匹配的是一直 连续的内容。**

    ```js
    // y 模式 使用 exec 的时候 遇见第二个 不是 g 的时候 他就停止了
    // 而 g 模式 会跳过 接着找  laseIndex 找不见的时候 会变成 0
    let str = "guoglin";
    let reg = /g/g;
    console.log(reg.exec(str)); // ["u", index: 1, input: "guoglin", groups: undefined]
    console.log(reg.exec(str)); // ["g", index: 3, input: "guoglin", groups: undefined]
    console.log(reg.exec(str)); // null

    let str1 = "guoglin";
    let reg1 = /g/y;
    console.log(reg1.exec(str1)); // ["u", index: 1, input: "guoglin", groups: undefined]
    console.log(reg1.exec(str1)); // null
    // FIXME:⚠️  可以改变它的 lastIndex 来让他找到可以匹配的内容
    ```

- **`lastIndex`属性。 控制正则开始搜索的位置。**

  ```js
  let hd = "houdunren";
  console.log(hd.match(/\w/)); // ["h", index: 0, input: "houdunren", groups: undefined]
  console.log(hd.match(/\w/g)); // (9) ["h", "o", "u", "d", "u", "n", "r", "e", "n"]

  console.log(/\w/g.exec(hd)); // ["h", index: 0, input: "houdunren", groups: undefined]
  console.log(/\w/g.exec(hd)); // ["h", index: 0, input: "houdunren", groups: undefined]

  let reg = /\w/g; // ⚠️注 还是需要变量存储的 否则就如同 上面 一直 不会记录位置
  // exec 这个方法 是使用全局的时候 才会去记录位置匹配 如果不使用的话 那就如同上面的一直都是第一个
  console.log(reg.lastIndex); // 0
  console.log(reg.exec(hd)); // ["h", index: 0, input: "houdunren", groups: undefined]
  console.log(reg.lastIndex); // 1
  console.log(reg.exec(hd)); // ["o", index: 1, input: "houdunren", groups: undefined]
  // 这样我们就可以 循环去操作
  while ((res = reg.exec(hd))) {
    console.log(res);
  }
  ```

- **原子表里面的区间匹配**

  - `eg: [0-9]` `[a-z]` 等等的。 ⚠️ 这里只能升序，不可以降序。 `[9-0]` 就会报错。

- **排除匹配**

  - `[^]` 排除

- **匹配全部**

  - `[\s\S]` - `[\w\W]` - `[\d\D]` 等等
  - `.` 是匹配 空格的 不匹配换行 换页 符

- **注意事项：⚠️**

  ```js
  [()] // ⚠️ () 放在外面 是原子组 里面就是括号
  [.+] // ⚠️ .+ 放在外面 是匹配 里面就是单纯的 .+
  / // ⚠️ 是正则的边界符， 所以需要转义一下。 \/
  /<(h[1-6])>.+<\/\1>/i // ⚠️ 这里面的 \1 就是表示 第一个 括号里面的内容
  ```

- **`\1 \2...`**

  - `()` 这个就当成了一个整体 然后想要复用的话可以从左到右就是 `\1\2\3...`
  - `/<(h[1-6])>.+<\/\1>/i` ⚠️ 这里面的 `\1` 就是表示 第一个 括号里面的内容

  - 依次类推 - `\1`就是第一个括号里面的 `\2...`
  - **⚠️ 数括号 就很简单了 就从左往右 数左括号 第一个左就是 `\1` 当然要区分开 条件判断和普通括号**

- 邮箱中原子组的使用

  ```js
  不写() /^\w\.com|org/ // 前面是一个整体后面 org 是一个整体 不能达到效果
  /^\w\.(com|org)/ // 这就表示匹配一个 后面com 和 org 判定的时候是一个 整体 ...
  ```

- `(?:)` 这样就 不会记录 原子组 ⚠️ 是括号里的

  ```js
  let gl = `
  https://www.houdunren.com
  https://houdunwang.com
  http://houdun.cn
  `;
  let reg = /https?:\/\/((?:\w+\.)?\w+\.(?:com|org|cn))/gi;
  let urls = [];
  while ((res = reg.exec(gl))) {
    urls.push(res[1]); // 这里的 就是 //后面第一个原子组里面存的数组
  }
  console.log(urls); // (3) ["www.houdunren.com", "houdunwang.com", "houdun.cn"]
  ```

- **贪婪匹配 能找到的 就尽可能的多个匹配**

- **多个正则规则 作用于一条 使用 数组循环 filter 或者 every 等等就可以解决**

- **禁止贪婪**

  - 就是加 `?` 因为 `?` 表示 0 个或者 1 个。
  - `+？ *？ {2,}? {2,100}? ` 禁止贪婪 倾向于少的一方

## 方法

**正则匹配的小技巧 - 尽量从小范围做起，然后再往 大范围的去匹配。 先具体化，然后再拼凑。**

- **`match`**

  `match` 方法可在字符串内检索指定的值，或找到一个或者多个正则表达式的匹配。

  `match` 返回一个数组。包括下标-匹配项-被匹配项。

  配合 `g` 模式 返回匹配项的数组。

  - 格式 - `字符串.match(正则表达式)`

- **`exec`**

  **和 `match` 返回的结果差不多。**

  不同的是： 格式 - `正则表达式.exec(字符串)`

  不同的是： 可以根据 `lastIndex` 来影响起始匹配。匹配后会更新 `lastIndex`属性

  ```js
  // 使用 exec 来完成全局匹配  这个 完全是因为 exec 受 lastIndex 影响会继续往后遍历 配合 g 模式
  while ((res = reg.exec(hd))) {
    // 如果没有 g 模式 就一直重复第一个 永远为true
    result.push(res);
  }
  console.log(result);
  ```

- **`matchAll`**

  **`matchAll` 方法返回一个迭代器 然后包括里面的搜索细节**

  ```js
  // 手动实现一个 matchAll 代码
  String.prototype.matchAll = function (reg) {
    let res = this.match(reg); // 调用 字符串的 match 方法
    if (res) {
      let str = this.replace(res[0], "^".repeat(res[0].length)); // repeat() 方法字符串复制指定次数。
      let match = str.matchAll(reg) || []; // 递归
      return [...res, ...match];
    }
  };
  ```

- **`replace`**

  ```js
  gl.replace(params1, params2);
  // params1  可以是 字符 也可以是 正则。 ⚠️
  // params2	可以是 字符 也可以是 函数。	⚠️

  // params2 是函数的情况
  // 函数参数1 - item 表示匹配到的整个内容
  // 🍃 函数参数2...(之后) - 就表示 第一个原子组(左往右 数第一个括号即可) 参数3-第二个 ...往后依次

  // params2 是字符串的情况
  // 🍃$1 就表示第一个原子组(左往右 数第一个括号即可) ...往后依次 $2 $3
  // 🍃$`表示匹配内容的左边  $'表示匹配内容的右边  $&表示匹配到的内容
  // 🍃?<别名> 这样就是给 原子组起别名 然后替换的时候 $<别名>就可以替换了。
  // 		(?<别名> ...) 写在原子组括号的最前面
  // 🍃?: 应用在原子组里面 就是排除查找。 然后使用match等方法匹配的时候 就匹配不到了
  // 		(?: ...) 写在原子组括号的最前面

  // 注意 ⚠️🍓
  // 在 正则表达式里面  使用 \1 \2 来表示第一个 第二个原子组。- 简写。 ...往后依次
  ```

- **`search`**

  **`search` 方法 返回下标 检索**

- **`test`**

  **`test` 方法 返回匹配后的 `true` 和 `false`**

  - 格式 - `正则表达式.test(字符串)`

- **`join`**

  **`join`方法 将数组组合成字符串。返回字符串。** 参数可以指定 标示符间隔 字符串。

- **`split`**

  **`split`方法 将字符串拆分 然后返回数组。** 里面参数也可以接收 正则 参数

## 断言匹配

**其实就是 正则的条件判断。**

- **`?=` 表示指定匹配项后面是啥。然后才会被匹配到。**

  ```js
  /后盾人(?=教程)/ // 表示匹配 后盾人并且后面是教程的 才会被匹配到
  (?=)  // 这个只是个条件 这个不是组
  ```

- **`?<=` 表示指定匹配项前面是啥。 然后才能被匹配到**

  ```js
  /(?<=houdunren)\d+/i // 表示要匹配前面是 后盾人的数字...
  /(?<=href=(['""])).+(?=\1)/ // ⚠️注意 (?<=href=(['"]))是断言  (['"]) 是主 只要加了括号
  ```

- **`?!` 表示指定匹配项后面不是什么 - 可以用来做 不能包含什么**

- **`?<!` 表示指定匹配项前面不是什么**

## 延伸

- **将字符串展开成数组**

  ```js
  let a = "guolin2020vxecho";
  console.log([...a]); // 这样可以展开成一个数组
  // (16) ["g", "u", "o", "l", "i", "n", "2", "0", "2", "0", "v", "x", "e", "c", "h", "o"]
  ```

- **寻找数字**

  - **数组查找**

    ```js
    ley nums = [...a].filter(item => !Number.isNaN(parseInt(item)));
    console.log('nums', nums); // nums (4) ["2", "0", "2", "0"]
    ```

  - **正则查找**

    ```js
    let num = a.match(/\d/g);
    console.log("num", num); // num (4) ["2", "0", "2", "0"]
    // .join('') 之后就可以将其 转换成 字符串~
    ```

### `e.g`

```js
let gl = `
 #1 js,200元 #
 #2 css,300元 #
 #8 guolin # 哈哈哈
 #3 node.js,100元 #
`;
// 结果想要如下 [{ name: 'js', price: '200元' }]; 的格式
// * 表示 0个或者多个  TODO: 尽量小范围做起 然后再匹配 大范围的  先具体化 然后拼凑
console.log(gl.match(/^\s*#\d+\s+.+\s#$/gm)); // ["↵ #1 js,200元 #", " #2 css,300元 #", " #3 node.js,100元 #"]
let testObj = gl.match(/^\s*#\d+\s+.+\s#$/gm).map((item) => {
  // 先替换前面的  在替换后面的
  item = item.replace(/\s*#\d+\s*/, "").replace(/\s#/, "");
  // console.log('item', item); // item node.js,100元
  // console.log('item.split', item.split(',')); // item.split (2) ["node.js", "100元 "]
  // TODO:⚠️  长知识了 这样可以进行结 解构 就可以改变生成结构
  [name, price] = item.split(",");
  return { name, price }; // map 返回 return 生成后的结果
});
console.log("testObj", testObj); // 0: {name: "js", price: "200元 "} 得到 结果 了
```
