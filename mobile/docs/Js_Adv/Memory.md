# `Js_Adv` - 内存

> 程序的运行需要内存。只要程序提出要求，操作系统或者运行时`runtime`就必须供给内存。
>
> 对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。
>
> 不再用到的内存，没有及时释放，就叫做内存泄漏 `memory leak`。
>
> 大多数语言提供自动内存管理，减轻程序员的负担，这被称为"垃圾回收机制" `garbage collector`。

## 前端为什么要关注内存？

任何程序的运行都需要分配内存空间。

**内存溢出 就是 我们所需要的内存空间大于可用内存。**

- **防止页面占用内存过大，引起客户端卡顿， 甚至无响应。**

> `NodeJs` 使用`V8`引擎。内存对于 后端服务 的性能至关重要，因为后端服务的持久性，后端更容易造成内存溢出。

## `Js`数据类型 与 `Js`内存机制

### 数据类型

- **原始数据类型**

  字符串`String` - 数字`Number` - 布尔`Boolean` - 空对象`Null` - 未定义`Undefined` - `Symbol`唯一值。

- **引用数据类型**

  对象`Object - Array - Function - RegExp...等等`

### 内存机制

**内存空间 - 栈`Stack`内存 & 堆`Heap`内存**

**`Js` 中的原始类型都有固定大小，保存在栈内存中，由系统自动分配空间，我们可以直接进行操作。**

**因此，原始数据类型 都是按值访问的。**

- **栈`Stack`**

  栈(先进后出) 是一种运行受限的线性表，限制就是**只允许在 表 的一端进行插入和删除。类似量杯。**

  > 从 栈顶插入。

  ```js
  // (入栈/进栈/压栈)
  var a = 10;
  var b = "hello";
  var c = true; // 最后 c 是 栈顶元素~
  var a = 10; // 以 a 为例
  ```

  > 过程：先存值`10`，然后在当前的作用域中，声明一个变量`a`(此时`a`并未赋值，为`undefined`)，
  >
  > 最后进行赋值 (`10`与`a`进行关联)

  ```js
  // 出栈/退栈
  c -> b -> a // 依次出栈。
  ```

`Js`中的 引用数据类型，**大小是不固定的，引用类型是在堆内存中存储。**

- **堆`Heap`**

**`Js`是不支持 直接操作堆内存的。**

**操作对象的时候，是对 堆内存 的引用（保存在栈内存的内存地址，与堆内存中实际值相关联）进行操作和访问。**

**所以引用类型的值，是保存 在堆内存中的对象。**

```js
// 声明对象
var obj1 = { a: 100 }; // 引用数据类型的时候
```

1. **在 堆内存 中开辟一个内存空间，以键值对`{ a: 100 } `的形式存在堆内存中。会有一个`16进制`的内存地址。假如是`0x8049368`。**

2. **在 栈内存 中声明一个变量`obj1`，值为`0x8049368`，利用这样就可以对堆内存的值进行关联并访问。**

```js
// 声明函数
function fn() {
  var i = 10;
  console.log(i);
}
```

1. **在堆内存中开辟一个内存空间，以字符串的形式，将代码存储，也会有一个`16进制`的内存地址。假如是`0x8049368`。**

2. **和上面类似，也是将`0x8049368`关联给 `fn函数`。**

> 验证：
>
> **`fn` - 不加括号执行的时候 就是 找到在堆内存中存储的 字符串代码。**
>
> **`fn()` - 才会执行，找到 字符串代码， 将其转变为`Js`代码进行执行。**

## 垃圾回收

**垃圾回收 是一种自动的 垃圾回收机制。**

**`Js`引擎找出那些不再继续使用的变量，然后释放其所占用的内存，垃圾回收器会按照固定的时候间隔周期性地执行这一操作。**

`Js`使用垃圾回收机制来自动管理 内存，垃圾回收是一把双刃剑。

- 优势： 可以**大幅简化程序的内存管理代码，降低程序员的负担，**减少因长时间运转而带来的内存泄漏问题。
- 不足： 意味着我们**程序员无法掌控内存**，`Js`没有暴露任何关于内存的`API`。我们无法强迫其进行垃圾回收，更无法干预。

### 引用计数

**跟踪记录 每个值被引用的次数，如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放。**

> **原理 -** 每次引用`+1`，被释放`-1`，当这个值的引用次数为`0`时，就可以将其 内存空间回收。

```js
var obj1 = { a: 10 }; // { a: 10 } 的引用次数 +1
var obj2 = { a: 10 }; // { a: 10 } 的引用次数 +1
obj1 = {}; // obj1 对 { a: 10 } 的引用次数 -1
obj1 = null; // obj1 对 { a: 10 } 对引用次数 为 0
obj2 = null; // obj2 对 { a: 10 } 对引用次数 为 0
```

> 声明一个 变量， 并将一个引用类型对值 赋给 这个变量，这个引用类型的值的引用次数 是`1`
>
> 同一个值 又被 赋值给另一个对象，这个引用类型值的`次数+1`
>
> 当包含这个 引用类型值的变量被 赋值给 另外一个值了，这个引用类型值的次数`-1`
>
> 当引用次数变成`0`，说明无法访问这个值了
>
> 当垃圾收集器下一次运行的时候，他就会释放引用次数是`0`的值所占的内存空间。

- **引用计数 - Bug - 循环引用**

  ```js
  function fn() {
    var obj1 = { a: 10 };
    var obj2 = { a: 10 };
    obj1.a = obj2; // obj1 的 a属性指向 obj2
    obj2.a = obj1; // obj2 的 b属性指向 obj1
    obj1 = null;
    obj2 = null;
  }
  ```

  > 执行完毕后，`obj1、obj2`的`a`属性引用次数都为`1`，都不会被回收。
  >
  > **所以 就会导致 内存泄漏。 只出现在`IE8`及其以前的浏览器中。**

> 现代浏览器 更多的使用 **标记清除** 来进行垃圾回收。

### 标记清除 🍓

**标记清除 指的是 当变量进入环境时，这个变量标记为进入环境，而 当变量离开环境的时候，则将其标记为 离开环境。**

**最后垃圾回收器完成内存清除工作，销毁并回收那些被标记为 离开环境 的值所占用的内存空间。**

- **执行环境**

  **变量或者函数 有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个 与之关联 的变量对象，环境中定义的所有变量和函数 都保存在这个对象中。**

  - **全局执行环境**

    最外围的环境，宿主环境不同，表示执行环境的变量对象也不一样。` e.g: Web - Window， Node - Global`

    全局变量和函数 都是作为 `window` 对象的变量和方法 传入的。

    **某个执行环境所有的代码执行完毕后，该环境被销毁。保存在其中所有的变量和函数都会被销毁。**

    `window`关闭浏览器的时候 才会被销毁。

  - **局部执行环境**

    每个函数都有自己的执行环境，**当执行流进入一个函数时，函数的环境就会被推入一个环境栈中(栈顶)。而在函数执行之后，栈将其环境弹出。**

    把控制权返回给之前的执行环境，`ECMAScript`程序中的执行流正式由这个方便的机制控制。

  ```js
  function foo() {
    var a = 10; // 被标记为 进入环境
    var b = "hello"; // 被标记为 进入环境
  }
  foo(); // 执行完毕， a b 被标记离开环境，内存被回收。
  ```

## `V8`的内存管理机制

### 限制内存的原因

`V8`最初为浏览器而设计，不太可能遇到大量内存的使用场景。

防止因为 **垃圾回收** 所导致的线程暂停执行的时间过长。

> 以 `1.5G` 的垃圾回收 为例， `V8`做一次小的垃圾回收 需要 `50ms` 以上。
>
> 这里的时间， 是在垃圾回收过程中，让`Js`暂停执行的时间。

- **`1.7G`是`V8`引擎的限制内存大小。**

> 我们可以使用 `Buffer` 对象，它是在 `C++` 层面进行的。不受 `V8` 引擎限制。

### 分代回收

`V8`采用了一种 **分代回收** 的策略，**将内存分为两个生代 - `新生代 和 老生代`。**

**`V8` 分别对 新生代 和 老生代 使用不同的 垃圾回收算法 来提升 垃圾回收的效率。**

- **新生代**

  **复制的方式进行垃圾回收** - 一个处于使用中`From` 一个处于闲置状态`To`。

  - 分配对象的时候 现在`From`中进行分配。 当 一个变量`a`需要被回收时，将其留在`From`空间。

  - 然后将`From`和`To`进行反转(互换)， 垃圾回收的时候 会将`To`空间的内存进行回收释放 将`a`进行回收。

  **新生代对象的晋升。**

  - **在新生代垃圾回收的过程中，当一个对象经过多次复制后，依然存活，它将认为是生命周期较长的对象。**
  - **随后会被移动到 老生代中**，采用新的算法进行管理。
  - 在`From`空间 和`To`空间**进行反转的过程**中，**如果`To`空间中使用量已经超过了`25%`**
  - 那么就将`From`中的对象**直接晋升到 老生代内存空间中。**

**新生代中用来存放 生命周期较短 的对象， 老生代中 用来存放 生命周期 较长 的对象**

**新生代中的对象 可以晋升到 老生代中。**

- **老生代**

  **老生代内存空间是一个连续的结构。**

  老生代垃圾回收 有 **标记清除 和 标记合并 两种方式。**

  - **标记清除 `Mark Sweep`**

    **是将需要被回收的对象进行标记，在垃圾回收运行时直接释放相对应的地址空间。**

    **`ABCDE - AB DF`**

    缺点就是 - 会出现内存不连续的情况。 **标记合并方案 解决这个问题。**

  - **标记合并 `Mark Compact`**

    **将存活的对象移动到一边，将需要被回收的对象移动到另外一边，然后对需要被回收的 对象区域 进行整体的垃圾回收。**

    **`ABCDE - C ABCE`**
